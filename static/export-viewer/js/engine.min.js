(function(){
  // Minimal engine for exported tours. Exposes global startTour(root, tourData)
  function degToRad(d){ return d * Math.PI / 180; }
  function lonLatToDir(lon, lat){
    // lon=x (horizontal), lat=y (vertical). Returns unit vector like the editor.
    var phi = degToRad(90 - lat);
    var theta = degToRad(lon);
    var x = Math.sin(phi) * Math.cos(theta);
    var y = Math.cos(phi);
    var z = Math.sin(phi) * Math.sin(theta);
    return new THREE.Vector3(x,y,z).normalize();
  }

  function start(root, tour){
    if (!root){ console.error('startTour: missing root element'); return; }
    if (!tour || !tour.scenes || !tour.scenes.length){
      showMsg('No scenes found in tour data.'); return;
    }
  if (typeof THREE === 'undefined'){ showMsg('Three.js not loaded.'); return; }

  // Debug helpers
  var __qs = new URLSearchParams((location && location.search) || '');
  var __debug = __qs.has('debug') || true; // Enable debug by default to troubleshoot
  function dbg(){ if (__debug || window.__vtDebug){ try{ console.log.apply(console, ['[VT]'].concat([].slice.call(arguments))); }catch(_){} } }
  window.__vtDebug = window.__vtDebug || true; // Enable debug by default
  window.__vtSetDebug = function(v){ __debug = !!v; window.__vtDebug = !!v; console.log('[VT] debug =', !!v); };
  
  // Log the tour data structure to help debug
  console.log('[VT] Tour data received:', tour);

    // UI helpers
    var overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:9999;';
    overlay.innerHTML = '<div style="background:#111;color:#fff;padding:12px 16px;border-radius:8px;max-width:90vw;max-height:90vh;box-shadow:0 8px 20px rgba(0,0,0,.4);">'
      + '<div id="vt-closeup-wrap" style="position:relative;overflow:hidden;max-width:80vw;max-height:80vh;background:#000;cursor:grab">'
  +   '<img id="vt-closeup" style="user-select:none;-webkit-user-drag:none;transform-origin:0 0;display:block;max-width:none;max-height:none"/>'
      + '</div>'
      + '<div style="display:flex;gap:8px;justify-content:space-between;align-items:center;margin-top:8px">'
      +   '<div style="font:12px sans-serif;opacity:.8">Scroll to zoom. Drag to pan.</div>'
      +   '<div><button id="vt-closeup-reset" style="padding:6px 10px;margin-right:6px">Reset</button><button id="vt-closeup-close" style="padding:6px 10px">Close</button></div>'
      + '</div>'
    + '</div>';
    document.body.appendChild(overlay);
    overlay.querySelector('#vt-closeup-close').onclick = function(){
      // hide and clear any inline size set on the wrap so it can return to CSS rules
      var wrap = overlay.querySelector('#vt-closeup-wrap');
      var img = overlay.querySelector('#vt-closeup');
      overlay.style.display = 'none';
      overlay.style.visibility = '';
      if (wrap) { wrap.style.width = ''; wrap.style.height = ''; }
      if (img) { img.src = ''; img.style.opacity = 0; }
  try{ renderer.domElement.style.pointerEvents = ''; }catch(_){ }
  try{ tooltip.style.display = 'none'; }catch(_){ }
    };

    function showMsg(text){
      var n = document.getElementById('notification');
      if (!n){ n = document.createElement('div'); n.id='notification'; n.style.cssText='position:fixed;top:12px;left:50%;transform:translateX(-50%);background:#222;color:#fff;padding:8px 12px;border-radius:4px;font-family:sans-serif;'; document.body.appendChild(n); }
      n.textContent = text; n.style.display='block';
    }

  // Three.js setup
    var width = root.clientWidth || window.innerWidth;
    var height = root.clientHeight || window.innerHeight;
  var renderer = new THREE.WebGLRenderer({ 
    antialias: false,  // Disabled for better performance
        powerPreference: "high-performance",
        alpha: false,      // No transparency needed
        depth: true,       // Keep depth buffer for proper rendering
        stencil: false     // No stencil buffer needed
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(width, height);
    // Color handling: keep renderer outputEncoding at the default to match the
    // editor's renderer. Forcing sRGB here caused exported panoramas to look
    // visually different (more faded/darker) compared to the editor.
    if (THREE) {
      // Do not override renderer.outputEncoding - leave default to match editor.
      // if (renderer.outputEncoding !== undefined && THREE.SRGBEncoding !== undefined) {
      //   renderer.outputEncoding = THREE.SRGBEncoding;
      // }
      // Disable tone mapping for exported viewer to match editor appearance
      if (renderer.toneMapping !== undefined && THREE.NoToneMapping !== undefined) {
        renderer.toneMapping = THREE.NoToneMapping;
      }
    }
  root.innerHTML = '';
    root.appendChild(renderer.domElement);
  dbg('startTour', { scenes: (tour.scenes||[]).length, initial_scene_id: tour.initial_scene_id });

  var scene = new THREE.Scene();
  // World group to rotate sphere and hotspots with north_dir
  var world = new THREE.Group();
  scene.add(world);
    var camera = new THREE.PerspectiveCamera( tour.initial_fov || 75, width/height, 0.1, 1000 );
    console.log('[VT] Camera FOV set to:', tour.initial_fov || 75);
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();

  var sphere, currentTexture;
    var hotspots = [];
    var currentScene = null;

    // Camera control state (mirror editor.js)
  var isDown=false, lon=0, lat=0, startX=0, startY=0;
  var momentum={x:0,y:0};
  var sensitivity=0.2; // editor.sensitivity
  var dampening=0.95;  // editor.dampening
    camera.target = new THREE.Vector3(0,0,0);

    // Texture caches/loaders
    var panoCache = Object.create(null);
    var iconCache = Object.create(null);
    var panoLoader = new THREE.TextureLoader();
    var iconLoader = new THREE.TextureLoader();
    function getPanoTexture(path){
      console.log('[VT] Loading panorama texture:', path);
      return new Promise(function(resolve, reject){
        if (panoCache[path]) return resolve(panoCache[path]);
        panoLoader.load(path, function(tex){ 
          console.log('[VT] Texture loaded successfully:', path);
          // Ensure correct color space/encoding depending on Three.js version
          // Keep texture encoding at the loader/default value to match the editor.
          // Forcing tex.encoding to sRGB here made exported panoramas appear
          // visually different from the editor in some environments.
          if (tex.needsUpdate !== undefined) tex.needsUpdate = true;
          panoCache[path] = tex; 
          resolve(tex); 
        }, undefined, function(err){ 
          console.error('[VT] Texture load failed:', path, err);
          reject(err); 
        });
      });
    }
    function getIconTexture(src, cb){
      if (iconCache[src]) { cb(iconCache[src]); return; }
      iconLoader.load(src, function(tex){
        try {
          if (tex.encoding !== undefined && THREE.SRGBEncoding !== undefined) tex.encoding = THREE.SRGBEncoding;
          else if (tex.colorSpace !== undefined && THREE.SRGBColorSpace !== undefined) tex.colorSpace = THREE.SRGBColorSpace;
        } catch(e) {}
        if (tex.needsUpdate !== undefined) tex.needsUpdate = true;
        iconCache[src] = tex; cb(tex);
      }, undefined, function(err){ console.warn('Icon load failed:', src, err); cb(null); });
    }
    function iconNameFor(conn){
      if (conn.connection_type === 'Transition') return 'transition_icon.png';
      var idx = (typeof conn.icon_index === 'number') ? conn.icon_index : (conn.icon_index ? Number(conn.icon_index) : 1);
      if (!idx || idx < 1 || idx > 3) idx = 1;
      return 'info' + idx + '_icon.png';
    }

    function setViewFromScene(sc){
      lon = (typeof sc.initial_view_x === 'number') ? sc.initial_view_x : 0;
      lat = (typeof sc.initial_view_y === 'number') ? sc.initial_view_y : 0;
      if (typeof sc.initial_fov === 'number') camera.fov = sc.initial_fov;
      camera.updateProjectionMatrix();
    }

    function buildPanorama(tex){
      var old = sphere;
      // Sphere geometry for pano. Slightly larger radius to avoid z-fighting during crossfade.
      var geom = new THREE.SphereGeometry(500.2, 64, 32);
      geom.scale(-1, 1, 1);
      // Disable depthWrite to avoid z-artifacts when fading; we render a single background.
      var mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.FrontSide, transparent: true, opacity: 0, depthWrite: false });
      sphere = new THREE.Mesh(geom, mat);
      sphere.renderOrder = -10;
      world.add(sphere);
      // quick crossfade (fade new in and old out)
      var start = performance.now();
      if (old && old !== sphere){
        if (old.material){ old.material.transparent = true; old.material.depthWrite = false; }
        old.renderOrder = -11;
      }
      function fade(){
        var t = (performance.now() - start) / 220; // ~220ms for smoother transition
        if (t >= 1){
          sphere.material.opacity = 1;
          if (old){ world.remove(old); disposeMesh(old); }
          return;
        }
        if (sphere && sphere.material) sphere.material.opacity = t;
        if (old && old.material) old.material.opacity = 1 - t;
        requestAnimationFrame(fade);
      }
      fade();
      try{
        var img = tex && tex.image; dbg('buildPanorama: texture', { w: img && (img.naturalWidth||img.width), h: img && (img.naturalHeight||img.height) });
      }catch(e){}
    }
    function disposeMesh(m){ try{ m.geometry.dispose(); if (m.material && m.material.map) m.material.map.dispose(); m.material && m.material.dispose && m.material.dispose(); }catch(e){} }

    // Current camera look direction from lon/lat (unit vector)
    function currentLookDir(){
      var phi = degToRad(90 - lat);
      var theta = degToRad(lon);
      var x = Math.sin(phi) * Math.cos(theta);
      var y = Math.cos(phi);
      var z = Math.sin(phi) * Math.sin(theta);
      return new THREE.Vector3(x,y,z).normalize();
    }

    function clearHotspots(){
  hotspots.forEach(function(h){ world.remove(h); if (h.material && h.material.map) h.material.map.dispose(); h.material && h.material.dispose && h.material.dispose(); });
      hotspots = [];
    }

  function makeSpriteForConnection(conn){
      // Visible colored placeholder until icon loads
      var size = 64;
          var c = document.createElement('canvas'); c.width=size; c.height=size; var ctx = c.getContext('2d');
      var isCloseup = (conn.connection_type === 'Closeup');
      var color = isCloseup ? '#e67e22' : '#18a0fb';
      ctx.beginPath(); ctx.arc(size/2, size/2, size/2-2, 0, Math.PI*2);
      ctx.fillStyle = color; ctx.fill();
      ctx.lineWidth = 3; ctx.strokeStyle = '#fff'; ctx.stroke();
      var tex = new THREE.CanvasTexture(c);
  // Keep canvas texture encoding default to match editor appearance (do not force sRGB).
  var mat = new THREE.SpriteMaterial({ map: tex, depthTest: false, depthWrite: false, transparent: true, alphaTest: 0.1 });
    var spr = new THREE.Sprite(mat);
  // Increased sprite sizes for better visibility
  var scalePx = isCloseup ? 36 : 44; // updated to be significantly larger
    spr.scale.set(scalePx, scalePx, 1);
      spr.renderOrder = 10; // draw above sphere if needed
      // Load actual icon texture and swap in
  var iconSrc = './assets/' + iconNameFor(conn);
      console.log('[VT] Loading icon:', iconSrc);
      getIconTexture(iconSrc, function(tex2){ if (tex2){ mat.map = tex2; mat.needsUpdate = true; } });
  spr.userData.__baseScale = scalePx;
      spr.userData.__isCloseup = isCloseup;
      return spr;
    }

  function placeHotspots(sc){
      clearHotspots();
  if (!Array.isArray(sc.connections)) { dbg('placeHotspots: no connections'); return; }
  dbg('placeHotspots: count', sc.connections.length);
      function parseLonLat(pos){
        try{
          if (pos == null) return null;
          var p = pos;
          if (typeof p === 'string') { p = JSON.parse(p); }
          if (Array.isArray(p) && p.length >= 2){
            var lon = Number(p[0]); var lat = Number(p[1]);
            if (!Number.isFinite(lon) || !Number.isFinite(lat)) return null;
            return { lon: lon, lat: lat };
          }
          if (typeof p === 'object'){
            var lon2 = Number(p.x); var lat2 = Number(p.y);
            if (Number.isFinite(lon2) && Number.isFinite(lat2)) return { lon: lon2, lat: lat2 };
          }
        }catch(e){ /* ignore */ }
        return null;
      }
      sc.connections.forEach(function(conn, idx){
        var spr = makeSpriteForConnection(conn);
        var parsed = parseLonLat(conn.position);
        // Place near the pano surface for better visual depth but avoid intersecting the sphere
        var distance = 490;
        var v = parsed ? lonLatToDir(parsed.lon, parsed.lat).setLength(distance) : currentLookDir().setLength(distance);
        spr.position.copy(v);
        spr.userData = { type: conn.connection_type, target: conn.target_scene_id, file_path: conn.file_path, name: conn.name };
        world.add(spr);
        hotspots.push(spr);
        console.log('[VT] Hotspot positioned:', { idx: idx, type: conn.connection_type, name: conn.name, distance: distance, pos: {x:v.x,y:v.y,z:v.z} });
        if (idx < 10) dbg('hotspot', { idx: idx, type: conn.connection_type, name: conn.name, target: conn.target_scene_id, icon_index: conn.icon_index, rawPos: conn.position, parsed: parsed, posLen: v.length(), pos: {x:v.x,y:v.y,z:v.z} });
      });
    }

    function loadSceneById(id){
      console.log('[VT] loadSceneById called with id:', id);
      console.log('[VT] Available scenes:', tour.scenes.map(function(s){ return {id: s.id, name: s.name}; }));
      var sc = tour.scenes.find(function(s){ return s.id === id; }) || tour.scenes[0];
      if (!sc){ showMsg('Scene not found'); return; }
      console.log('[VT] Loading scene:', sc);
      currentScene = sc;
      setViewFromScene(sc);
      // Apply scene north_dir to world rotation (match editor orientation)
      var nd = sc.north_dir || 0;
      world.rotation.set(0, degToRad(nd), 0);
      var fp = sc.file_path || '';
      var path = (fp[0] === '/') ? fp.slice(1) : fp; // trim leading '/'
      console.log('[VT] Texture path:', path);
      dbg('loadSceneById', { id: sc.id, name: sc.name, north_dir: nd, initial_view_x: sc.initial_view_x, initial_view_y: sc.initial_view_y, initial_fov: sc.initial_fov, file_path: path });
      getPanoTexture(path).then(function(tex){ currentTexture = tex; buildPanorama(tex); placeHotspots(sc); preloadNeighbors(sc); }).catch(function(err){ console.error('Texture load failed', err); showMsg('Failed to load scene image: '+path); });
    }

    function preloadNeighbors(sc){
      if (!Array.isArray(sc.connections)) return;
      sc.connections.forEach(function(conn){
        if (conn.connection_type !== 'Transition' || !conn.target_scene_id) return;
        var ns = tour.scenes.find(function(s){ return s.id === conn.target_scene_id; });
        if (!ns || !ns.file_path) return; var p = ns.file_path; var path = (p[0] === '/') ? p.slice(1) : p;
        if (!panoCache[path]) { getPanoTexture(path).catch(function(){}); }
      });
    }

    function onResize(){
      var w = root.clientWidth || window.innerWidth;
      var h = root.clientHeight || window.innerHeight;
      renderer.setSize(w,h); camera.aspect = w/h; camera.updateProjectionMatrix();
      dbg('resize', { w:w, h:h, aspect: camera.aspect });
    }

  function onPointerDown(e){ isDown=true; startX=e.clientX; startY=e.clientY; momentum.x=0; momentum.y=0; dbg('pointerDown', {x:e.clientX,y:e.clientY}); }
  function onPointerMove(e){ if (!isDown) return; var dx=e.clientX-startX, dy=e.clientY-startY; var moveX=dx*sensitivity, moveY=dy*sensitivity; lon = (lon - moveX) % 360; lat = (lat + moveY) % 360; lat = Math.max(-85, Math.min(85, lat)); momentum.x = moveX*0.5; momentum.y = moveY*0.5; startX=e.clientX; startY=e.clientY; if ((__debug||window.__vtDebug)) { if ((Math.abs(dx)>1)||(Math.abs(dy)>1)) dbg('pointerMove', {dx:dx,dy:dy,lon:lon,lat:lat}); } }
  function onPointerUp(){ isDown=false; }
    function onWheel(e){ e.preventDefault(); var fov = camera.fov + e.deltaY*0.05; camera.fov = Math.max(10, Math.min(120, fov)); camera.updateProjectionMatrix(); dbg('wheel', { fov: camera.fov }); }

    function onClick(e){
      var rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      var intersects = raycaster.intersectObjects(hotspots, false);
      if (intersects && intersects.length){
        var obj = intersects[0].object; var data = obj.userData || {};
        dbg('click hotspot', { name: data.name, type: data.type, target: data.target });
        if (data.type === 'Transition' && data.target){
          loadSceneById(data.target);
        } else if (data.type === 'Closeup' && data.file_path){
          var p = data.file_path || '';
          var src = (p[0] === '/') ? p.slice(1) : p;
          overlay.style.display='flex';
          if (typeof overlay.__setCloseupSrc === 'function') overlay.__setCloseupSrc(src); else { var img = overlay.querySelector('#vt-closeup'); img.src = src; }
        }
      }
    }

    // Tooltip for hotspot titles (mirror editor hover behavior)
    var tooltip = document.createElement('div');
    tooltip.style.cssText = 'position:fixed;pointer-events:none;background:rgba(0,0,0,0.75);color:#fff;padding:4px 8px;border-radius:4px;font:12px/1.2 sans-serif;z-index:9999;display:none;max-width:50vw;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;';
    document.body.appendChild(tooltip);
    function getSceneNameById(id){ var s = tour.scenes.find(function(sc){ return sc.id === id; }); return s ? (s.name || '') : ''; }
    function onMouseMove(e){
      // If the closeup modal is open, hide tooltip and skip hover logic to avoid visual conflicts
      if (overlay && overlay.style && overlay.style.display && overlay.style.display !== 'none'){
        try{ tooltip.style.display = 'none'; }catch(_){ }
        return;
      }
      var rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(hotspots, false);
      if (intersects && intersects.length){
        var obj = intersects[0].object; var d = obj.userData || {};
        var label = '';
        if (d.type === 'Closeup') label = d.name || 'Closeup';
        else label = d.name || getSceneNameById(d.target) || '';
        if (label){
          tooltip.textContent = label;
          tooltip.style.left = (e.clientX + 12) + 'px';
          tooltip.style.top = (e.clientY + 12) + 'px';
          tooltip.style.display = 'block';
          renderer.domElement.style.cursor = 'pointer';
          dbg('hover hotspot', { label: label, type: d.type, target: d.target });
          return;
        }
      }
      tooltip.style.display = 'none';
      renderer.domElement.style.cursor = '';
    }

  var __frame = 0;
  function update(){
        // Apply momentum when not actively dragging (match editor.js)
        if (!isDown && (Math.abs(momentum.x) > 0.005 || Math.abs(momentum.y) > 0.005)){
          var x_dir = momentum.x > 0 ? 1 : -1;
          var y_dir = momentum.y > 0 ? 1 : -1;
          momentum.x = Math.min(0.8, Math.abs(momentum.x)) * x_dir;
          momentum.y = Math.min(0.8, Math.abs(momentum.y)) * y_dir;
          lon -= momentum.x;
          lat += momentum.y;
          lat = Math.max(-85, Math.min(85, lat));
          momentum.x *= dampening;
          momentum.y *= dampening;
          if (Math.abs(momentum.x) < 0.005) momentum.x = 0;
          if (Math.abs(momentum.y) < 0.005) momentum.y = 0;
        }
        // Compute camera look direction directly from lon/lat (like editor.updateCamera)
        var phi = degToRad(90 - lat);
        var theta = degToRad(lon);
        var dirX = Math.sin(phi) * Math.cos(theta);
        var dirY = Math.cos(phi);
        var dirZ = Math.sin(phi) * Math.sin(theta);
        camera.position.set(0,0,0);
        camera.up.set(0,1,0);
        camera.lookAt(dirX, dirY, dirZ);
        // Adjust hotspot sprite sizes to keep consistent on-screen size (like editor)
        if (hotspots.length){
          var baseFov = 75;
          var f = Math.tan(degToRad(camera.fov * 0.5));
          var fBase = Math.tan(degToRad(baseFov * 0.5));
          var factor = f / fBase;
          // Increase min/max sizes so larger icons are preserved at common FOVs
          var minS = 14, maxS = 120;
          for (var i=0;i<hotspots.length;i++){
            var s = hotspots[i];
            var base = s.userData.__baseScale || 26;
            var target = Math.max(minS, Math.min(maxS, base * factor));
            s.scale.set(target, target, 1);
          }
          if (((__debug||window.__vtDebug)) && (++__frame % 60 === 0)){
            var sample = hotspots[0];
            dbg('scaleTick', { fov: camera.fov, factor: factor, sampleScale: sample ? sample.scale.x : undefined });
          }
        }
    }

    function animate(){
      requestAnimationFrame(animate);
      update();
      renderer.render(scene, camera);
    }

    // Closeup zoom/pan controls
    (function(){
      var wrap = overlay.querySelector('#vt-closeup-wrap');
      var img = overlay.querySelector('#vt-closeup');
      var scale = 1, tx = 0, ty = 0; var dragging=false, px=0, py=0;
      function apply(){
        // Apply translation in screen pixels regardless of scale by dividing
        // translation by scale before the CSS translate so the final on-screen
        // offset equals tx/ty (translate is scaled by the following scale()).
        var sx = (scale && scale !== 0) ? (tx / scale) : tx;
        var sy = (scale && scale !== 0) ? (ty / scale) : ty;
        img.style.transform = 'translate('+sx+'px,'+sy+'px) scale('+scale+')';
      }
      // Clamp keeps the image within the visible bounds. When the image is smaller than
      // the container we center it; when larger, we constrain pan to edges.
      function clamp(){
        try{
          var rect = wrap.getBoundingClientRect();
          // Use layout/displayed size (offsetWidth) rather than natural size so CSS sizing is respected
          var baseW = (img.offsetWidth && img.offsetWidth > 0) ? img.offsetWidth : (img.naturalWidth || rect.width || 1);
          var baseH = (img.offsetHeight && img.offsetHeight > 0) ? img.offsetHeight : (img.naturalHeight || rect.height || 1);
          var w = baseW * scale;
          var h = baseH * scale;

          // Compute applied-space bounds (what the CSS translate should be)
          var minAppliedTx = rect.width - w; // applied translate left-most (sx)
          var maxAppliedTx = 0;             // applied translate right-most
          var minAppliedTy = rect.height - h; // applied translate top-most (sy)
          var maxAppliedTy = 0;               // applied translate bottom-most

          // Stored tx/ty are in scaled units (apply divides by scale). Convert applied bounds
          // to stored-space by multiplying by scale so we clamp the same units as tx/ty.
          var minTxStored = minAppliedTx * scale;
          var maxTxStored = maxAppliedTx * scale;
          var minTyStored = minAppliedTy * scale;
          var maxTyStored = maxAppliedTy * scale;

          if (w <= rect.width){
            // center horizontally when image (scaled) is smaller than the container (stored units)
            tx = ((rect.width - w) / 2) * scale;
          } else {
            // clamp in stored units
            tx = Math.min(maxTxStored, Math.max(minTxStored, tx));
          }

          if (h <= rect.height){
            // center vertically when image (scaled) is smaller than the container (stored units)
            ty = ((rect.height - h) / 2) * scale;
          } else {
            // clamp in stored units
            ty = Math.min(maxTyStored, Math.max(minTyStored, ty));
          }

          // Compute transformed image corner positions in wrap coordinates
          var sx = (scale && scale !== 0) ? (tx / scale) : tx;
          var sy = (scale && scale !== 0) ? (ty / scale) : ty;
          var corners = {
            imageLeft: sx,
            imageTop: sy,
            imageRight: sx + w,
            imageBottom: sy + h,
            minTx: minTx,
            maxTx: maxTx,
            minTy: minTy,
            maxTy: maxTy
          };

          if (window.__vtCloseupDebug){
            console.log('clampExact', { rectW: rect.width, rectH: rect.height, baseW: baseW, baseH: baseH, scale: scale, w: w, h: h, tx: tx, ty: ty, sx: sx, sy: sy, corners: corners });
          }
        }catch(e){ /* ignore clamp errors */ }
      }
      wrap.addEventListener('wheel', function(e){
        e.preventDefault();
        var delta = -Math.sign(e.deltaY) * 0.1;
        var ns = Math.min(5, Math.max(1, scale + delta));
        if (ns === scale) return;
        var rect = wrap.getBoundingClientRect();
        // Cursor position relative to wrap
        var cx = e.clientX - rect.left;
        var cy = e.clientY - rect.top;
        // If cursor is outside the wrap, anchor at center
        var anchorX = (cx >= 0 && cx <= rect.width && cy >= 0 && cy <= rect.height) ? cx : (rect.width / 2);
        var anchorY = (cx >= 0 && cx <= rect.width && cy >= 0 && cy <= rect.height) ? cy : (rect.height / 2);

        // Convert stored tx/ty to applied-space (what translate() sees), compute new applied translate
        var s = scale;
        var sx = (s && s !== 0) ? (tx / s) : tx;
        var sy = (s && s !== 0) ? (ty / s) : ty;
        var nsf = ns;
        var sx2 = (sx - anchorX) * (nsf / s) + anchorX;
        var sy2 = (sy - anchorY) * (nsf / s) + anchorY;
        // Store tx/ty in stored units (applied * newScale)
        tx = sx2 * nsf;
        ty = sy2 * nsf;
        scale = nsf;
        clamp();
        apply();
      }, { passive:false });
      overlay.querySelector('#vt-closeup-reset').addEventListener('click', function(){
        scale=1; tx=0; ty=0; clamp(); apply();
      });
      wrap.addEventListener('dblclick', function(){ scale=1; tx=0; ty=0; clamp(); apply(); });
      wrap.addEventListener('mousedown', function(e){ if (scale<=1) return; dragging=true; px=e.clientX; py=e.clientY; wrap.style.cursor='grabbing'; });
      window.addEventListener('mousemove', function(e){
        if (!dragging) return;
        var dx = e.clientX - px, dy = e.clientY - py;
        px = e.clientX; py = e.clientY;
        // tx/ty are stored in scaled units. To make pan feel consistent when zoomed,
        // convert mouse delta (applied pixels) to stored units by multiplying by current scale.
        var mul = (scale && scale > 0) ? scale : 1;
        tx += dx * mul;
        ty += dy * mul;
        clamp(); apply();
      });
      window.addEventListener('mouseup', function(){ if (dragging){ dragging=false; wrap.style.cursor='grab'; }});
      overlay.__setCloseupSrc = function(src){
        // Prepare image element
  img.style.transition = 'opacity 160ms ease';
  img.style.opacity = 0;
  img.style.transformOrigin = '0 0';
        // Reset transform while loading
        scale = 1; tx = 0; ty = 0; apply();

  // Make overlay participate in layout so we can measure sizes, but keep it hidden
  // Hide any existing hotspot tooltip and disable pointer events on the renderer
  try{ tooltip.style.display = 'none'; }catch(_){ }
  try{ renderer.domElement.style.pointerEvents = 'none'; }catch(_){ }
  overlay.style.display = 'flex';
  overlay.style.visibility = 'hidden';

        // Rely on CSS to size the image to the wrap (max-width/max-height inlined below).
        // Remove JS-driven wrap sizing and use the layout/displayed image size for centering/clamping.
        img.style.maxWidth = '100%';
        img.style.maxHeight = '100%';
        img.style.width = 'auto';
        img.style.height = 'auto';

        img.onload = function(){
          try{
            // Natural image size
            var iw = img.naturalWidth || img.width || 1;
            var ih = img.naturalHeight || img.height || 1;
            // Available viewport space (leave some margin)
            var availW = Math.max(100, Math.min(window.innerWidth * 0.95, window.innerWidth - 40));
            var availH = Math.max(80, Math.min(window.innerHeight * 0.95, window.innerHeight - 80));
            // Compute scale to fit the full image into the viewport (never upscale)
            var fit = Math.min(1, availW / iw, availH / ih);
            var displayW = Math.round(iw * fit);
            var displayH = Math.round(ih * fit);
            // Size the wrap to the scaled image so the modal tightly wraps the image
            wrap.style.width = displayW + 'px';
            wrap.style.height = displayH + 'px';
            // Make the image fill the wrap exactly
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.maxWidth = 'none';
            img.style.maxHeight = 'none';
            // Reset transform and center
            scale = 1; tx = 0; ty = 0; clamp(); apply();
            // reveal overlay and fade-in image
            overlay.style.visibility = 'visible';
            requestAnimationFrame(function(){ img.style.opacity = 1; });
            console.log("closeup displayed (fit: ", fit, ", size:", displayW, displayH, ")");
          }catch(e){
            scale = 1; tx = 0; ty = 0; apply(); overlay.style.visibility = 'visible'; img.style.opacity = 1;
          }
        };
        // Start loading image (overlay is display:flex but hidden so measurements are correct)
        img.src = src;
      };
    })();

    // Events
    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
  renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
  renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('click', onClick);

    // init
    var initialId = tour.initial_scene_id || (tour.scenes[0] && tour.scenes[0].id);
    console.log('[VT] Initial scene ID:', initialId);
    console.log('[VT] Tour initial_scene_id:', tour.initial_scene_id);
    console.log('[VT] First scene ID:', tour.scenes[0] && tour.scenes[0].id);
    loadSceneById(initialId);
    onResize();
    animate();
  }

  // expose
  window.startTour = start;
})();
