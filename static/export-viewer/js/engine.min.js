(function(){
  // Minimal engine for exported tours. Exposes global startTour(root, tourData)
  function degToRad(d){ return d * Math.PI / 180; }
  function lonLatToDir(lon, lat){
    // lon=x (horizontal), lat=y (vertical). Returns unit vector like the editor.
    var phi = degToRad(90 - lat);
    var theta = degToRad(lon);
    var x = Math.sin(phi) * Math.cos(theta);
    var y = Math.cos(phi);
    var z = Math.sin(phi) * Math.sin(theta);
    return new THREE.Vector3(x,y,z).normalize();
  }

  function start(root, tour){
    if (!root){ console.error('startTour: missing root element'); return; }
    if (!tour || !tour.scenes || !tour.scenes.length){
      showMsg('No scenes found in tour data.'); return;
    }
    if (typeof THREE === 'undefined'){ showMsg('Three.js not loaded.'); return; }

    // UI helpers
    var overlay = document.createElement('div');
    overlay.style.cssText = 'position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:9999;';
    overlay.innerHTML = '<div style="background:#111;color:#fff;padding:12px 16px;border-radius:8px;max-width:90vw;max-height:90vh;box-shadow:0 8px 20px rgba(0,0,0,.4);">'
      + '<div id="vt-closeup-wrap" style="position:relative;overflow:hidden;max-width:80vw;max-height:80vh;background:#000;cursor:grab">'
      +   '<img id="vt-closeup" style="user-select:none;-webkit-user-drag:none;transform-origin:center center;display:block;max-width:none;max-height:none"/>'
      + '</div>'
      + '<div style="display:flex;gap:8px;justify-content:space-between;align-items:center;margin-top:8px">'
      +   '<div style="font:12px sans-serif;opacity:.8">Scroll to zoom. Drag to pan.</div>'
      +   '<div><button id="vt-closeup-reset" style="padding:6px 10px;margin-right:6px">Reset</button><button id="vt-closeup-close" style="padding:6px 10px">Close</button></div>'
      + '</div>'
    + '</div>';
    document.body.appendChild(overlay);
    overlay.querySelector('#vt-closeup-close').onclick = function(){ overlay.style.display='none'; };

    function showMsg(text){
      var n = document.getElementById('notification');
      if (!n){ n = document.createElement('div'); n.id='notification'; n.style.cssText='position:fixed;top:12px;left:50%;transform:translateX(-50%);background:#222;color:#fff;padding:8px 12px;border-radius:4px;font-family:sans-serif;'; document.body.appendChild(n); }
      n.textContent = text; n.style.display='block';
    }

  // Three.js setup
    var width = root.clientWidth || window.innerWidth;
    var height = root.clientHeight || window.innerHeight;
  var renderer = new THREE.WebGLRenderer({ 
    antialias: false,  // Disabled for better performance
        powerPreference: "high-performance",
        alpha: false,      // No transparency needed
        depth: true,       // Keep depth buffer for proper rendering
        stencil: false     // No stencil buffer needed
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(width, height);
    // Improve color correctness on older Three.js builds
    if (THREE && THREE.sRGBEncoding && renderer.outputEncoding !== undefined) {
      renderer.outputEncoding = THREE.sRGBEncoding;
    }
    root.innerHTML = '';
    root.appendChild(renderer.domElement);

  var scene = new THREE.Scene();
  // World group to rotate sphere and hotspots with north_dir
  var world = new THREE.Group();
  scene.add(world);
    var camera = new THREE.PerspectiveCamera( tour.initial_fov || 75, width/height, 0.1, 1000 );
    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();

  var sphere, currentTexture;
    var hotspots = [];
    var currentScene = null;

    // Camera control state (mirror editor.js)
  var isDown=false, lon=0, lat=0, startX=0, startY=0;
  var momentum={x:0,y:0};
  var sensitivity=0.2; // editor.sensitivity
  var dampening=0.95;  // editor.dampening
    camera.target = new THREE.Vector3(0,0,0);

    // Texture caches/loaders
    var panoCache = Object.create(null);
    var iconCache = Object.create(null);
    var panoLoader = new THREE.TextureLoader();
    var iconLoader = new THREE.TextureLoader();
    function getPanoTexture(path){
      return new Promise(function(resolve, reject){
        if (panoCache[path]) return resolve(panoCache[path]);
        panoLoader.load(path, function(tex){ tex.colorSpace = THREE.SRGBColorSpace; panoCache[path] = tex; resolve(tex); }, undefined, function(err){ reject(err); });
      });
    }
    function getIconTexture(src, cb){
      if (iconCache[src]) { cb(iconCache[src]); return; }
      iconLoader.load(src, function(tex){ tex.colorSpace = THREE.SRGBColorSpace; iconCache[src] = tex; cb(tex); }, undefined, function(err){ console.warn('Icon load failed:', src, err); cb(null); });
    }
    function iconNameFor(conn){
      if (conn.connection_type === 'Transition') return 'transition_icon.png';
      var idx = (typeof conn.icon_index === 'number') ? conn.icon_index : (conn.icon_index ? Number(conn.icon_index) : 1);
      if (!idx || idx < 1 || idx > 3) idx = 1;
      return 'info' + idx + '_icon.png';
    }

    function setViewFromScene(sc){
      lon = (typeof sc.initial_view_x === 'number') ? sc.initial_view_x : 0;
      lat = (typeof sc.initial_view_y === 'number') ? sc.initial_view_y : 0;
      if (typeof sc.initial_fov === 'number') camera.fov = sc.initial_fov;
      camera.updateProjectionMatrix();
    }

    function buildPanorama(tex){
      var old = sphere;
      var geom = new THREE.SphereGeometry(500, 64, 32);
      geom.scale(-1, 1, 1);
      var mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.FrontSide, transparent: true, opacity: 0 });
  sphere = new THREE.Mesh(geom, mat);
  world.add(sphere);
      // quick crossfade
      var start = performance.now();
      function fade(){
        var t = (performance.now() - start) / 180; // ~180ms
  if (t >= 1){ sphere.material.opacity = 1; if (old){ world.remove(old); disposeMesh(old); } return; }
        sphere.material.opacity = t;
        requestAnimationFrame(fade);
      }
      fade();
      if (old && old !== sphere){ old.material.transparent = true; old.material.opacity = 1; }
    }
    function disposeMesh(m){ try{ m.geometry.dispose(); if (m.material && m.material.map) m.material.map.dispose(); m.material && m.material.dispose && m.material.dispose(); }catch(e){} }

    // Current camera look direction from lon/lat (unit vector)
    function currentLookDir(){
      var phi = degToRad(90 - lat);
      var theta = degToRad(lon);
      var x = Math.sin(phi) * Math.cos(theta);
      var y = Math.cos(phi);
      var z = Math.sin(phi) * Math.sin(theta);
      return new THREE.Vector3(x,y,z).normalize();
    }

    function clearHotspots(){
  hotspots.forEach(function(h){ world.remove(h); if (h.material && h.material.map) h.material.map.dispose(); h.material && h.material.dispose && h.material.dispose(); });
      hotspots = [];
    }

    function makeSpriteForConnection(conn){
      // Visible colored placeholder until icon loads
      var size = 64;
      var c = document.createElement('canvas'); c.width=size; c.height=size; var ctx = c.getContext('2d');
      var isCloseup = (conn.connection_type === 'Closeup');
      var color = isCloseup ? '#e67e22' : '#18a0fb';
      ctx.beginPath(); ctx.arc(size/2, size/2, size/2-2, 0, Math.PI*2);
      ctx.fillStyle = color; ctx.fill();
      ctx.lineWidth = 3; ctx.strokeStyle = '#fff'; ctx.stroke();
      var tex = new THREE.CanvasTexture(c);
  var mat = new THREE.SpriteMaterial({ map: tex, depthTest: false, depthWrite: false, transparent: true, alphaTest: 0.1, sizeAttenuation: false });
  var spr = new THREE.Sprite(mat);
  var scalePx = isCloseup ? 28 : 32; // base size; we will adjust per FOV
  spr.scale.set(scalePx, scalePx, 1);
      spr.renderOrder = 10; // draw above sphere if needed
      // Load actual icon texture and swap in
  var iconSrc = './assets/' + iconNameFor(conn);
      getIconTexture(iconSrc, function(tex2){ if (tex2){ mat.map = tex2; mat.needsUpdate = true; } });
  spr.userData.__baseScale = scalePx;
  spr.userData.__isCloseup = isCloseup;
      return spr;
    }

    function placeHotspots(sc){
      clearHotspots();
      if (!Array.isArray(sc.connections)) return;
      function parseLonLat(pos){
        try{
          if (pos == null) return null;
          var p = pos;
          if (typeof p === 'string') { p = JSON.parse(p); }
          if (Array.isArray(p) && p.length >= 2){
            var lon = Number(p[0]); var lat = Number(p[1]);
            if (!Number.isFinite(lon) || !Number.isFinite(lat)) return null;
            return { lon: lon, lat: lat };
          }
          if (typeof p === 'object'){
            var lon2 = Number(p.x); var lat2 = Number(p.y);
            if (Number.isFinite(lon2) && Number.isFinite(lat2)) return { lon: lon2, lat: lat2 };
          }
        }catch(e){ /* ignore */ }
        return null;
      }
      sc.connections.forEach(function(conn){
        var spr = makeSpriteForConnection(conn);
  var parsed = parseLonLat(conn.position);
  var v = parsed ? lonLatToDir(parsed.lon, parsed.lat).setLength(499) : currentLookDir().setLength(5000);
        spr.position.copy(v);
        spr.userData = { type: conn.connection_type, target: conn.target_scene_id, file_path: conn.file_path, name: conn.name };
  world.add(spr);
        hotspots.push(spr);
      });
    }

    function loadSceneById(id){
      var sc = tour.scenes.find(function(s){ return s.id === id; }) || tour.scenes[0];
      if (!sc){ showMsg('Scene not found'); return; }
  currentScene = sc;
      setViewFromScene(sc);
  // Apply scene north_dir to world rotation (match editor orientation)
  var nd = sc.north_dir || 0;
  world.rotation.set(0, degToRad(nd), 0);
      var fp = sc.file_path || '';
      var path = (fp[0] === '/') ? fp.slice(1) : fp; // trim leading '/'
      getPanoTexture(path).then(function(tex){ currentTexture = tex; buildPanorama(tex); placeHotspots(sc); preloadNeighbors(sc); }).catch(function(err){ console.error('Texture load failed', err); showMsg('Failed to load scene image: '+path); });
    }

    function preloadNeighbors(sc){
      if (!Array.isArray(sc.connections)) return;
      sc.connections.forEach(function(conn){
        if (conn.connection_type !== 'Transition' || !conn.target_scene_id) return;
        var ns = tour.scenes.find(function(s){ return s.id === conn.target_scene_id; });
        if (!ns || !ns.file_path) return; var p = ns.file_path; var path = (p[0] === '/') ? p.slice(1) : p;
        if (!panoCache[path]) { getPanoTexture(path).catch(function(){}); }
      });
    }

    function onResize(){
      var w = root.clientWidth || window.innerWidth;
      var h = root.clientHeight || window.innerHeight;
      renderer.setSize(w,h); camera.aspect = w/h; camera.updateProjectionMatrix();
    }

  function onPointerDown(e){ isDown=true; startX=e.clientX; startY=e.clientY; momentum.x=0; momentum.y=0; }
  function onPointerMove(e){ if (!isDown) return; var dx=e.clientX-startX, dy=e.clientY-startY; var moveX=dx*sensitivity, moveY=dy*sensitivity; lon = (lon - moveX) % 360; lat = (lat + moveY) % 360; lat = Math.max(-85, Math.min(85, lat)); momentum.x = moveX*0.5; momentum.y = moveY*0.5; startX=e.clientX; startY=e.clientY; }
  function onPointerUp(){ isDown=false; }
    function onWheel(e){ e.preventDefault(); var fov = camera.fov + e.deltaY*0.05; camera.fov = Math.max(10, Math.min(120, fov)); camera.updateProjectionMatrix(); }

    function onClick(e){
      var rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      var intersects = raycaster.intersectObjects(hotspots, false);
      if (intersects && intersects.length){
        var obj = intersects[0].object; var data = obj.userData || {};
        if (data.type === 'Transition' && data.target){
          loadSceneById(data.target);
        } else if (data.type === 'Closeup' && data.file_path){
          var p = data.file_path || '';
          var src = (p[0] === '/') ? p.slice(1) : p;
          overlay.style.display='flex';
          if (typeof overlay.__setCloseupSrc === 'function') overlay.__setCloseupSrc(src); else { var img = overlay.querySelector('#vt-closeup'); img.src = src; }
        }
      }
    }

    // Tooltip for hotspot titles (mirror editor hover behavior)
    var tooltip = document.createElement('div');
    tooltip.style.cssText = 'position:fixed;pointer-events:none;background:rgba(0,0,0,0.75);color:#fff;padding:4px 8px;border-radius:4px;font:12px/1.2 sans-serif;z-index:9999;display:none;max-width:50vw;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;';
    document.body.appendChild(tooltip);
    function getSceneNameById(id){ var s = tour.scenes.find(function(sc){ return sc.id === id; }); return s ? (s.name || '') : ''; }
    function onMouseMove(e){
      var rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      var intersects = raycaster.intersectObjects(hotspots, false);
      if (intersects && intersects.length){
        var obj = intersects[0].object; var d = obj.userData || {};
        var label = '';
        if (d.type === 'Closeup') label = d.name || 'Closeup';
        else label = d.name || getSceneNameById(d.target) || '';
        if (label){
          tooltip.textContent = label;
          tooltip.style.left = (e.clientX + 12) + 'px';
          tooltip.style.top = (e.clientY + 12) + 'px';
          tooltip.style.display = 'block';
          renderer.domElement.style.cursor = 'pointer';
          return;
        }
      }
      tooltip.style.display = 'none';
      renderer.domElement.style.cursor = '';
    }

    function update(){
        // Apply momentum when not actively dragging (match editor.js)
        if (!isDown && (Math.abs(momentum.x) > 0.005 || Math.abs(momentum.y) > 0.005)){
          var x_dir = momentum.x > 0 ? 1 : -1;
          var y_dir = momentum.y > 0 ? 1 : -1;
          momentum.x = Math.min(0.8, Math.abs(momentum.x)) * x_dir;
          momentum.y = Math.min(0.8, Math.abs(momentum.y)) * y_dir;
          lon -= momentum.x;
          lat += momentum.y;
          lat = Math.max(-85, Math.min(85, lat));
          momentum.x *= dampening;
          momentum.y *= dampening;
          if (Math.abs(momentum.x) < 0.005) momentum.x = 0;
          if (Math.abs(momentum.y) < 0.005) momentum.y = 0;
        }
        // Compute camera look direction directly from lon/lat (like editor.updateCamera)
        var phi = degToRad(90 - lat);
        var theta = degToRad(lon);
        var dirX = Math.sin(phi) * Math.cos(theta);
        var dirY = Math.cos(phi);
        var dirZ = Math.sin(phi) * Math.sin(theta);
        camera.position.set(0,0,0);
        camera.up.set(0,1,0);
        camera.lookAt(dirX, dirY, dirZ);
        // Adjust hotspot sprite sizes to keep consistent on-screen size (like editor)
        if (hotspots.length){
          var baseFov = 75;
          var f = Math.tan(degToRad(camera.fov * 0.5));
          var fBase = Math.tan(degToRad(baseFov * 0.5));
          var factor = f / fBase;
          var minS = 18, maxS = 80;
          for (var i=0;i<hotspots.length;i++){
            var s = hotspots[i];
            var base = s.userData.__baseScale || 32;
            var target = Math.max(minS, Math.min(maxS, base * factor));
            s.scale.set(target, target, 1);
          }
        }
    }

    function animate(){
      requestAnimationFrame(animate);
      update();
      renderer.render(scene, camera);
    }

    // Closeup zoom/pan controls
    (function(){
      var wrap = overlay.querySelector('#vt-closeup-wrap');
      var img = overlay.querySelector('#vt-closeup');
      var scale = 1, tx = 0, ty = 0; var dragging=false, px=0, py=0;
      function apply(){ img.style.transform = 'translate('+tx+'px,'+ty+'px) scale('+scale+')'; }
      function clamp(){ if (scale <= 1){ tx = 0; ty = 0; } }
      wrap.addEventListener('wheel', function(e){ e.preventDefault(); var delta = -Math.sign(e.deltaY) * 0.1; var ns = Math.min(5, Math.max(1, scale + delta)); var rect = wrap.getBoundingClientRect(); var cx = e.clientX - rect.left - rect.width/2; var cy = e.clientY - rect.top - rect.height/2; if (ns !== scale){ tx = (tx - cx) * (ns/scale) + cx; ty = (ty - cy) * (ns/scale) + cy; scale = ns; clamp(); apply(); } }, { passive:false });
      overlay.querySelector('#vt-closeup-reset').addEventListener('click', function(){ scale=1; tx=0; ty=0; apply(); });
      wrap.addEventListener('dblclick', function(){ scale=1; tx=0; ty=0; apply(); });
      wrap.addEventListener('mousedown', function(e){ if (scale<=1) return; dragging=true; px=e.clientX; py=e.clientY; wrap.style.cursor='grabbing'; });
      window.addEventListener('mousemove', function(e){ if (!dragging) return; var dx=e.clientX-px, dy=e.clientY-py; px=e.clientX; py=e.clientY; tx += dx; ty += dy; apply(); });
      window.addEventListener('mouseup', function(){ if (dragging){ dragging=false; wrap.style.cursor='grab'; }});
      overlay.__setCloseupSrc = function(src){
        // Fit image to container on open, then allow zoom/pan
        img.onload = function(){
          var rect = wrap.getBoundingClientRect();
          var iw = img.naturalWidth || rect.width; var ih = img.naturalHeight || rect.height;
          var s = Math.min(rect.width / iw, rect.height / ih);
          if (!(s > 0) || !isFinite(s)) s = 1;
          scale = s; tx = 0; ty = 0; apply();
        };
        scale=1; tx=0; ty=0; img.style.transformOrigin='center center'; img.src=src; apply();
      };
    })();

    // Events
    window.addEventListener('resize', onResize);
    renderer.domElement.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
  renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
  renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('click', onClick);

    // init
    var initialId = tour.initial_scene_id || (tour.scenes[0] && tour.scenes[0].id);
    loadSceneById(initialId);
    onResize();
    animate();
  }

  // expose
  window.startTour = start;
})();
